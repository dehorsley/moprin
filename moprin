#!/usr/bin/env python3 
#Moprin: oprin for muliple stations!
#Dave Horsley
#Nov. 2014

import atexit
import os
import sys
import time
from select import select
import socket
from subprocess import Popen, PIPE
from random import random

import readline

# python doesn't include a binding to rl_callback_read_char, so we have to import it manually
import ctypes
rl_lib = ctypes.cdll.LoadLibrary("libreadline.so.6")
readline.callback_handler_remove = rl_lib.rl_callback_handler_remove
readline.callback_read_char = rl_lib.rl_callback_read_char
readline.delete_text = rl_lib.rl_delete_text
readline.redisplay = rl_lib.rl_redisplay
readline.end = ctypes.c_int.in_dll(rl_lib,'rl_end')

# the callback needs special treatment:
rlcallbackfunctype = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_char_p)
def setcallbackfunc(prompt, thefunc):
    prompt = prompt.encode()
    readline.callback = rlcallbackfunctype(thefunc)
    rl_lib.rl_callback_handler_install(prompt, readline.callback)

readline.callback_handler_install = setcallbackfunc


#ANSI codes for cursor motion and colours
HIDE = "\033[?25l"
SHOW = "\033[?25h"
SAVE = "\033[s"
RESTORE = "\033[u"
PREVLINE = "\033[F"

RESET = "\033[0m"
RED =   "\033[31m"
GREEN = "\033[32m"
YELLOW ="\033[33m"


#Colours used for the job state
statecols = {None: YELLOW, False: RED, True: GREEN}

#Readline hist and completion
histfile = os.path.join(os.path.expanduser("~"), ".moprin_hist")
try:
    readline.read_history_file(histfile)
except IOError:
    pass
atexit.register(readline.write_history_file, histfile)


#Extra commands can go here
commands = ['clkoff','maserdelay','exit','stations', 'stns','iread','bread']

#If the fscmd.ctl file is available, append the commands to the tab completion list
#lines starting with '*' are comments and ignored
#The stcmd.ctl file could be added here too
try:
    f = open('/usr2/fs/control/fscmd.ctl')
    commands.extend( [l.split()[0] for l in f if l[0] != '*'])
except:
    pass

commands.sort()

# Readline completion function. 
# Readline repeatedly calls the complete function with various index until the function returns None
def complete(prefix, index):
    if index == 0:
        #complete.matches = 
        if prefix in  ['schedule=', 'log=','proc=']:
            #TODO: complete based on exp master file
            pass
        else:
            self.matches = [ w for w in self.words if w.startswith(prefix) ]

    else:
        try:
            return complete.matches[index]
        except IndexError:
            return None

readline.parse_and_bind("tab: complete")
readline.set_completer(complete)


SSH_CMD = ['ssh', '-q',
                  '-o','"ControlMaster=auto"',
                  '-o','"ControlPath=~/.ssh/moprin-%r@%h:%p"',
                  '-o','"ControlPersist 10m"',
                  ]


#Class to store info about commands sent, can update their status, and display it in the correct location in the terminal

class Job:
    def __init__(self, command):
        self.command = command

        global ln
        self.ln = ln-1
        global stations
        self.stations = stations

        # Dict of the Popen objects for each request
        self.procs = dict.fromkeys(stations) 
        # states of each process
        #   None: pending, True: done successfully, False: failed
        self.states = dict.fromkeys(stations) 

        # Global complete flag
        self.done = False

        for stn in self.stations:
            global pc
            self.procs[stn] = Popen(SSH_CMD.extend([pc[stn], 'inject_snap','\'%s\'' % command.replace("$s",stn)]),stderr=PIPE,stdout=PIPE)
            

    def update(self):
        # Update the states based on procs and render it to the terminal

        numdone = 0
        prompt = []

        for stn in self.stations:
            proc = self.procs[stn]
            if proc.poll() != None:
                if proc.returncode == 0:
                    self.states[stn] = True
                else:
                    self.states[stn] = False
                numdone += 1

            prompt.append("%s%s%s" %(statecols[self.states[stn]], stn, RESET))


        if numdone == len(self.stations):
            self.done = True

        prompt = "-".join(prompt)

        global ln
        #TODO: be more intelligent about moving up lines
        print( "".join([HIDE , SAVE , (ln-self.ln)*PREVLINE ,  prompt , "> " , RESTORE , SHOW]) ,end='',flush=True)


#Fildsystem computers of the corresponding station id
pc =  { "hb": "pcfshb",
        "ke": "pcfske",
        "yg": "pcfsyg",
        "ho": "hobart",
        "cd": "pcfscd",
        }

def process_input(l):
    global stations
    global jobs

    if l is None:
        print("")
        sys.exit()

    l = l.decode()
    l = l.strip()

    global ln
    ln = ln + 1

    if l in ['exit', 'quit']:
        sys.exit()

    elif l.startswith('stations') or l.startswith('stns'):
        new_stns = l.split()
        if len(new_stns) == 1:
            print(" ".join(stations))
        else:
            new_stns = new_stns[1:]
            for stn in new_stns:
                if stn not in pc:
                    print("Unknown station: '%s' " % stn)
                    break
            else:
                stations = new_stns
        
    elif l == 'help':
        print("""'Moprin' is 'oprin' for multiple remote stations. It can send command to remote field systems over ssh. \
To set the remote stations for the session, use the command 'stations' or 'stns' followed by the two letter station IDs separated by spaces. \
Alternatively, you can give the list of remote stations in the arguments when you start moprin. \
Running the 'stations' command without arguments gives the list of active stations. 

The text '$s' in a command will be replaced by the corresponding two-letter station ID when sent to the remote field systems.

To exit moprin, type 'exit' or press Ctrl+D.

History is stored in ~/.moprin_hist and tab-completion is enabled.
""")
    
    elif l != '':
        readline.add_history(l)
        #async send commands via ssh
        j = Job(l)
        jobs.append(j)

        # print(len(jobs))
        # ln += 1

    prompt = '%s> ' % '-'.join(stations)
    setcallbackfunc(prompt, process_input)

#Globals to store the line number, the running jobs and the slave stations
ln = 1
jobs = []
if len(sys.argv) == 1:
    stations = ["hb", "ke", "yg"]
else:
    stations = sys.argv[1:]
    for stn in stations:
        if stn not in pc:
            print("Unknown station: %s" % stn)
            sys.exit()

prompt = '%s> ' % '-'.join(stations)
setcallbackfunc(prompt, process_input)
#Main Loop
while True:
    try:
        r, w, x = select([sys.stdin], [], [], 0.05)

        if sys.stdin in r:
            readline.callback_read_char()
        else:
            #Between key presses, tidy up the rest
            for i, job in enumerate(jobs):
                job.update()
                if job.done:
                    del jobs[i]

    except KeyboardInterrupt: #Kill line on Ctrl+C
        print("^C")
        ln += 1
        readline.delete_text(0,readline.end)
        prompt = '%s> ' % '-'.join(stations)
        setcallbackfunc(prompt, process_input)
        readline.redisplay()
